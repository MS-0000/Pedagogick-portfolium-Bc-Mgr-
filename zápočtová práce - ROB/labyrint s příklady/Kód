import tkinter as tk
from tkinter import messagebox
import random
import openpyxl


# ------------------- P콎칈KLADY -------------------

def nacti_ulohy(soubor):
    workbook = openpyxl.load_workbook(soubor)
    sheet = workbook.active
    ulohy = []
    for row in sheet.iter_rows(min_row=1, values_only=True):
        zadani, vysledek = row[1], row[2]
        ulohy.append((zadani, vysledek))
    return ulohy


def start_kolo(typ):
    global priklady, index, spravne
    cesta = f"{typ}.xlsx"
    priklady = random.sample(nacti_ulohy(cesta), 4)
    index = 0
    spravne = 0
    zobraz_priklad()


def zobraz_priklad():
    global index
    if index < 4:
        zadani_label.config(text=f"P콏칤klad {index + 1}: {priklady[index][0]}")
        odpoved_entry.delete(0, tk.END)
    else:
        messagebox.showinfo("Hotovo", "Spr치vn캩 jsi vy콏e코il 4 p콏칤klady!\nTe캞 za캜ne bludi코t캩 游꿡")
        if 'okno' in globals() and okno.winfo_exists():
                okno.destroy()# skryj okno s 칰lohami
        start_bludiste()


def zkontroluj():
    global index, spravne
    odpoved = odpoved_entry.get()

    if odpoved == str(priklady[index][1]):
        spravne += 1
        index += 1  # posun na dal코칤 p콏칤klad
        if spravne >= 4:
            messagebox.showinfo("Hotovo", "Spr치vn캩 jsi vy콏e코il 4 p콏칤klady!\nTe캞 za캜ne bludi코t캩 游꿡")
            if 'okno' in globals() and okno.winfo_exists():
                okno.destroy()
            start_bludiste()
            return
    else:
        # pouze upozorn캩n칤, bez zobrazen칤 spr치vn칠 odpov캩di
        messagebox.showwarning("Chyba", "맗atn캩! Zkus to znovu.")

    # zobraz dal코칤 p콏칤klad, pokud jsme u spr치vn칠 odpov캩di
    if index < len(priklady):
        zobraz_priklad()

def menu_volby():
    global okno
    okno = tk.Toplevel(root)
    okno.title("V칳b캩r typu 칰loh")
    tk.Label(okno, text="Vyber typ 칰loh:").pack(pady=10)
    for typ in ["scitani", "odcitani", "nasobeni", "deleni"]:
        tk.Button(okno, text=typ.capitalize(),
                  command=lambda t=typ: [okno.destroy(), start_kolo(t)]).pack(pady=5)


# ------------------- BLUDIT캨 -------------------

ROWS, COLS = 15, 15
cell_size = 30


def init_maze(rows, cols):
    return [[1 for _ in range(cols)] for _ in range(rows)]


def generate_maze(maze, x, y):
    maze[y][x] = 0
    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
    random.shuffle(directions)
    for dx, dy in directions:
        nx, ny = x + dx * 2, y + dy * 2
        if 0 < nx < COLS and 0 < ny < ROWS and maze[ny][nx] == 1:
            maze[y + dy][x + dx] = 0
            generate_maze(maze, nx, ny)
    return maze


def start_bludiste():
    global maze, player_pos, start_pos, end_pos, canvas
    maze = init_maze(ROWS, COLS)
    maze = generate_maze(maze, 1, 1)
    start_pos = (1, 1)
    end_pos = (ROWS - 2, COLS - 2)
    maze[start_pos[1]][start_pos[0]] = 0
    maze[end_pos[1]][end_pos[0]] = 0
    player_pos = list(start_pos)

    bludiste_window = tk.Toplevel(root)
    bludiste_window.title("Bludi코t캩")
    bludiste_window.geometry(f"{COLS * cell_size}x{ROWS * cell_size}")
    bludiste_window.focus_set()

    canvas = tk.Canvas(bludiste_window, width=COLS * cell_size, height=ROWS * cell_size)
    canvas.pack()

    colors = {0: "white", 1: "black", "player": "blue", "start": "green", "end": "red"}

    def draw_maze():
        canvas.delete("all")
        for y in range(ROWS):
            for x in range(COLS):
                fill = colors[maze[y][x]]
                if (x, y) == tuple(player_pos):
                    fill = colors["player"]
                elif (x, y) == start_pos:
                    fill = colors["start"]
                elif (x, y) == end_pos:
                    fill = colors["end"]
                canvas.create_rectangle(x * cell_size, y * cell_size,
                                        (x + 1) * cell_size, (y + 1) * cell_size,
                                        fill=fill, outline="gray")

    def move(event):
        x, y = player_pos
        if event.keysym == 'Up':
            ny = y - 1
            if ny >= 0 and maze[ny][x] == 0: player_pos[1] = ny
        elif event.keysym == 'Down':
            ny = y + 1
            if ny < ROWS and maze[ny][x] == 0: player_pos[1] = ny
        elif event.keysym == 'Left':
            nx = x - 1
            if nx >= 0 and maze[y][nx] == 0: player_pos[0] = nx
        elif event.keysym == 'Right':
            nx = x + 1
            if nx < COLS and maze[y][nx] == 0: player_pos[0] = nx
        draw_maze()
        check_win()

    def check_win():
        if tuple(player_pos) == end_pos:
            messagebox.showinfo("Gratulace!", "Dorazil jsi do c칤le!")
            bludiste_window.destroy()
            menu_volby()

    bludiste_window.bind("<Key>", move)
    draw_maze()


# ------------------- Hlavn칤 okno -------------------

root = tk.Tk()
root.title("Matematick칳 labyrint")

zadani_label = tk.Label(root, text="Vyber si typ 칰loh v menu", font=("Arial", 14))
zadani_label.pack(pady=20)

odpoved_entry = tk.Entry(root, font=("Arial", 14))
odpoved_entry.pack(pady=10)

tk.Button(root, text="Odpov캩d캩t", command=zkontroluj).pack(pady=10)
tk.Button(root, text="Vybrat 칰lohy", command=menu_volby).pack(pady=10)

root.mainloop()
